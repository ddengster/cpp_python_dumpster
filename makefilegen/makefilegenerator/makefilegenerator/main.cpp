
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <Windows.h>
using namespace std;

string gnumakefilename("makefile.gnu");
string microsoftmakefilename("makefile.microsoft");
string borlandmakefilename("makefile.borland");

string gnucompilersettings("-Wall -Wextra -Werror -ansi -pedantic -Wl,--enable-auto-import");
string microsoftcompilersettings("/W4 /EHa /WX /Za"); //can add /nologo here
string borlandcompilersettings("-w -q");

vector<string> cppfilestocompile;
vector<string> headerfilestocompile;

string outputname("MYOUTPUT.exe");

enum MAINMENUCHOICES
{
	SETMAKEFILESTOGENERATE = 1,
	SETCOMPILERSETTINGS,
	ADDFILES,
	SETOUTPUTFILENAME,
	GENMAKEFILES,
	QUIT
};

void GenerateGNU();
void GenerateVC7();
void GenerateBORLAND();

void GenerateMakefiles()
{
	FILE* filecreate;
	fopen_s(&filecreate, gnumakefilename.c_str(), "w");
	fclose(filecreate);
	fopen_s(&filecreate, microsoftmakefilename.c_str(), "w");
	fclose(filecreate);
	fopen_s(&filecreate, borlandmakefilename.c_str(), "w");
	fclose(filecreate);

	GenerateGNU();
	GenerateVC7();
	GenerateBORLAND();
}

void GenerateBORLAND()
{
	fstream file;
	file.open(borlandmakefilename, std::fstream::out);
	
	string initialdata;
	initialdata.append("# Generated by ddeng's makefile generator!\n"); //add this when others are using!
	initialdata.append("# Macros ========================================\n");
	initialdata.append("CC=bcc32\n");
	initialdata.append("CFLAGS="); initialdata.append(borlandcompilersettings);
	initialdata.append("\nOUTDIR=borland\\\\\n");
	initialdata.append("OBJECTS=");
	//add obj file for each cpp file
	string objfilename;
	for (unsigned int i=0; i<cppfilestocompile.size(); i++)
	{
		initialdata.append("$(OUTDIR)");
		objfilename = cppfilestocompile[i].substr(0, cppfilestocompile[i].size()-4);//remove .cpp
		initialdata.append(objfilename); 
		initialdata.append(".obj ");
	}
	
	initialdata.append("\n");
	initialdata.append("EXE="); initialdata.append(outputname);
	initialdata.append("\nERASE=rm");

	file.write(initialdata.c_str(), initialdata.size());

	string targets;
	targets.append("\n# Targets ========================================\n");
	targets.append("$(OUTDIR)$(EXE) : $(OBJECTS)\n");
	targets.append("    $(CC) -o $(OUTDIR)$(EXE) $(OBJECTS)\n\n");

	string objfilename2;
	//for each .cpp file, print out, then search for a similar .h file to add to
	for (unsigned int i=0; i<cppfilestocompile.size(); i++)
	{
		targets.append("$(OUTDIR)");
		objfilename = cppfilestocompile[i].substr(0, cppfilestocompile[i].size()-4);//remove .cpp
		targets.append(objfilename);
		targets.append(".obj : ");
		targets.append(cppfilestocompile[i]);

		for (unsigned int h=0; h<headerfilestocompile.size(); h++)
		{
			targets.append(" ");
			objfilename2 = headerfilestocompile[h].substr(0, headerfilestocompile[h].size()-2);//remove .h
			if (objfilename == objfilename2)
			{
				targets.append(headerfilestocompile[h]);
				break;
			}
		}
		targets.append("\n");
		targets.append("    $(CC) -o $(OUTDIR)");
		targets.append(objfilename);
		targets.append(".obj $(CFLAGS) -c ");
		targets.append(cppfilestocompile[i]);
		targets.append("\n");
	}
	
	file.write(targets.c_str(), targets.size());

	string final;
	final.append("\nclean: \n");
	final.append("	$(ERASE) $(OBJECTS) $(OUTDIR)$(EXE)\n\n");
	final.append("rebuild: \n");
	final.append("	$(ERASE) $(OBJECTS) $(OUTDIR)$(EXE)\n");
	final.append("	$(MAKE) -f ");
	final.append(borlandmakefilename);
	final.append("-i\n");

	file.write(final.c_str(), final.size());

	file.close();
}

void GenerateVC7()
{
	fstream file;
	file.open(microsoftmakefilename, std::fstream::out);
	
	string initialdata;
	initialdata.append("# Generated by ddeng's makefile generator!\n"); //add this when others are using!
	initialdata.append("# Macros ========================================\n");
	initialdata.append("CC=cl\n");
	initialdata.append("CFLAGS="); initialdata.append(microsoftcompilersettings);
	initialdata.append("\nOUTDIR=microsoft\\\\\n");
	initialdata.append("OBJECTS=");
	//add obj file for each cpp file
	string objfilename;
	for (unsigned int i=0; i<cppfilestocompile.size(); i++)
	{
		initialdata.append("$(OUTDIR)");
		objfilename = cppfilestocompile[i].substr(0, cppfilestocompile[i].size()-4);//remove .cpp
		initialdata.append(objfilename); 
		initialdata.append(".obj ");
	}
	
	initialdata.append("\n");
	initialdata.append("EXE="); initialdata.append(outputname);
	initialdata.append("\nERASE=rm");

	file.write(initialdata.c_str(), initialdata.size());

	string targets;
	targets.append("\n# Targets ========================================\n");
	targets.append("$(OUTDIR)$(EXE) : $(OBJECTS)\n");
	targets.append("    $(CC) /Fe$(OUTDIR)$(EXE) $(OBJECTS)\n\n");

	string objfilename2;
	//for each .cpp file, print out, then search for a similar .h file to add to
	for (unsigned int i=0; i<cppfilestocompile.size(); i++)
	{
		targets.append("$(OUTDIR)");
		objfilename = cppfilestocompile[i].substr(0, cppfilestocompile[i].size()-4);//remove .cpp
		targets.append(objfilename);
		targets.append(".obj : ");
		targets.append(cppfilestocompile[i]);

		for (unsigned int h=0; h<headerfilestocompile.size(); h++)
		{
			targets.append(" ");
			objfilename2 = headerfilestocompile[h].substr(0, headerfilestocompile[h].size()-2);//remove .h
			if (objfilename == objfilename2)
			{
				targets.append(headerfilestocompile[h]);
				break;
			}
		}
		targets.append("\n");
		targets.append("    $(CC) /Fo$(OUTDIR)");
		targets.append(objfilename);
		targets.append(".obj $(CFLAGS) /c ");
		targets.append(cppfilestocompile[i]);
		targets.append("\n");
	}
	
	file.write(targets.c_str(), targets.size());

	string final;
	final.append("\nclean: \n");
	final.append("	$(ERASE) $(OBJECTS) $(OUTDIR)$(EXE)\n\n");
	final.append("rebuild: \n");
	final.append("	$(ERASE) $(OBJECTS) $(OUTDIR)$(EXE)\n");
	final.append("	$(MAKE) -f ");
	final.append(microsoftmakefilename);
	final.append("-i\n");

	file.write(final.c_str(), final.size());

	file.close();
}

void GenerateGNU()
{
	fstream file;
	file.open(gnumakefilename, std::fstream::out);
	
	string initialdata;
	initialdata.append("# Generated by ddeng's makefile generator!\n"); //add this when others are using!
	initialdata.append("# Macros ========================================\n");
	initialdata.append("CC=g++\n");
	initialdata.append("CFLAGS="); initialdata.append(gnucompilersettings);
	initialdata.append("\nOUTDIR=gnu\\\\\n");
	initialdata.append("OBJECTS=");
	//add obj file for each cpp file
	string objfilename;
	for (unsigned int i=0; i<cppfilestocompile.size(); i++)
	{
		initialdata.append("$(OUTDIR)");
		objfilename = cppfilestocompile[i].substr(0, cppfilestocompile[i].size()-4);//remove .cpp
		initialdata.append(objfilename); 
		initialdata.append(".obj ");
	}
	
	initialdata.append("\n");
	initialdata.append("EXE="); initialdata.append(outputname);
	initialdata.append("\nERASE=rm");

	file.write(initialdata.c_str(), initialdata.size());

	string targets;
	targets.append("\n# Targets ========================================\n");
	targets.append("$(OUTDIR)$(EXE) : $(OBJECTS)\n");
	targets.append("    $(CC) -o $(OUTDIR)$(EXE) $(OBJECTS)\n\n");

	string objfilename2;
	//for each .cpp file, print out, then search for a similar .h file to add to
	for (unsigned int i=0; i<cppfilestocompile.size(); i++)
	{
		targets.append("$(OUTDIR)");
		objfilename = cppfilestocompile[i].substr(0, cppfilestocompile[i].size()-4);//remove .cpp
		targets.append(objfilename);
		targets.append(".obj : ");
		targets.append(cppfilestocompile[i]);

		for (unsigned int h=0; h<headerfilestocompile.size(); h++)
		{
			targets.append(" ");
			objfilename2 = headerfilestocompile[h].substr(0, headerfilestocompile[h].size()-2);//remove .h
			if (objfilename == objfilename2)
			{
				targets.append(headerfilestocompile[h]);
				break;
			}
		}
		targets.append("\n");
		targets.append("    $(CC) -o $(OUTDIR)");
		targets.append(objfilename);
		targets.append(".obj $(CFLAGS) -c ");
		targets.append(cppfilestocompile[i]);
		targets.append("\n");
	}
	
	file.write(targets.c_str(), targets.size());

	string final;
	final.append("\nclean: \n");
	final.append("	$(ERASE) $(OBJECTS) $(OUTDIR)$(EXE)\n\n");
	final.append("rebuild: \n");
	final.append("	$(ERASE) $(OBJECTS) $(OUTDIR)$(EXE)\n");
	final.append("	$(MAKE) -f ");
	final.append(gnumakefilename);
	final.append("-i\n");

	file.write(final.c_str(), final.size());

	file.close();
}

void AddFile()
{
	int choice = 0;
	const int quit = 3;
	while (choice != quit)
	{
		cout << "--------------------------------------\n"
			 << "What file to add?\n"
			 << "1) cpp file\n"
			 << "2) header coupled with cpp file\n"
			 << "3) Quit\n";
		cin >> choice;

		string filename;
		if (choice == 1)
		{
			cout << "Enter cpp filename without .cpp extension: ";
			cin >> filename;
			cppfilestocompile.push_back(filename.append(".cpp"));
		}
		else if (choice == 2)
		{
			cout << "Enter header and cpp filename without .cpp or .h extension: ";
			cin >> filename;
			cppfilestocompile.push_back(filename.append(".cpp"));
			headerfilestocompile.push_back(filename.append(".h"));
		}
	}
}

void RemoveFile()
{
	string filename;
	cout << "Enter header and cpp filename without .cpp or .h extension: ";
	cin >> filename;

	for (unsigned int i=0; i<cppfilestocompile.size(); i++)
	{
		if (cppfilestocompile[i] == filename)
			cout << filename << ".cpp removed\n";
	}
	for (unsigned int i=0; i<headerfilestocompile.size(); i++)
	{
		if (headerfilestocompile[i] == filename)
			cout << filename << ".h removed\n";
	}
}

void SetFilesToCompile()
{
	int choice = 0;
	const int quit = 4;
	while (choice != quit)
	{
		cout << "--------------------------------------\n"
			 << "Current files to compile: \n";

		for (unsigned int i=0; i<cppfilestocompile.size(); i++)
			cout << cppfilestocompile[i] << endl;
		for (unsigned int i=0; i<headerfilestocompile.size(); i++)
			cout << headerfilestocompile[i] << endl;
		
		cout << "--------------------------------------\n"
			 << "1) Add file\n"
			 << "2) Remove file\n"
			 << "3) Remove all files\n"
			 << "4) Quit\n"
			 << "--------------------------------------\n";

		cin >> choice;

		if (choice == 1)
			AddFile();
		else if (choice == 2)
			RemoveFile();
		else if (choice == 3)
		{
			cppfilestocompile.clear();
			headerfilestocompile.clear();
		}

	}
}

void SetMakefileCompilerSettings()
{
	int choice = 0;
	const int quit = 4;
	while (choice != quit)
	{
		cout << "--------------------------------------\n"
			 << "Default compiler settings for makefiles: \n"
			 << "1) GNU: " << gnucompilersettings << endl
			 << "2) MICROSOFT: " << microsoftcompilersettings << endl
			 << "3) BORLAND: " << borlandcompilersettings << endl
			 << "--------------------------------------\n";
		cout << "Choice: ";
		cin >> choice;

		string compilersettings;
		switch (choice)
		{
		case 1:
			cout << "Enter GNU compiler settings: ";
			cin >> compilersettings;
			gnucompilersettings = compilersettings;
			break;
		case 2:
			cout << "Enter MICROSOFT compiler settings: ";
			cin >> compilersettings;
			microsoftcompilersettings = compilersettings;
			break;
		case 3:
			cout << "Enter BORLAND compiler settings: ";
			cin >> compilersettings;
			borlandcompilersettings = compilersettings;
			break;
		}
	}
}

void SetMakefilesToGenerate()
{
	int choice = 0;
	const int quit = 4;
	while (choice != quit)
	{
		cout << "--------------------------------------\n"
			 << "Default name for makefiles: \n"
			 << "1) GNU: " << gnumakefilename << endl
			 << "2) MICROSOFT: " << microsoftmakefilename << endl
			 << "3) BORLAND: " << borlandmakefilename << endl
			 << "--------------------------------------\n";
		cout << "Choice: ";
		cin >> choice;

		string newfilename;
		switch (choice)
		{
		case 1:
			cout << "Enter GNU file name: ";
			cin >> newfilename;
			gnumakefilename = newfilename;
			break;
		case 2:
			cout << "Enter MICROSOFT file name: ";
			cin >> newfilename;
			microsoftmakefilename = newfilename;
			break;
		case 3:
			cout << "Enter BORLAND file name: ";
			cin >> newfilename;
			borlandmakefilename = newfilename;
			break;
		}
	}
}

void SetOutputFileName()
{
	string newfilename;
	cout << "--------------------------------------\n"
		 << "Current output file name: "
		 << outputname << endl
		 << "Change to: ";
	cin >> newfilename;
	outputname = newfilename;
}

void AddCppAndHeaderFilesInDirectory()
{
	WIN32_FIND_DATA FindFileData; 
	HANDLE hFind = INVALID_HANDLE_VALUE; 

	cout << "Getting files in current directory...\n";
	hFind = FindFirstFile(".\\*", &FindFileData);

	string filename = FindFileData.cFileName;
	if (filename.find(".cpp") != string::npos)
		cppfilestocompile.push_back(filename);
	else if (filename.find(".h") != string::npos)
		headerfilestocompile.push_back(filename);

	while(FindNextFile(hFind, &FindFileData) != 0)
	{
		filename = FindFileData.cFileName;
		if (filename.find(".cpp") != string::npos)
			cppfilestocompile.push_back(filename);
		else if (filename.find(".h") != string::npos)
			headerfilestocompile.push_back(filename);
	}

	FindClose(hFind);
}
int main()
{
	AddCppAndHeaderFilesInDirectory();

	int choice = 0;

	while (choice != QUIT)
	{
		system("cls");
		cout << "--------------------------------------\n"
			 << "Welcome to ddeng's makefile generator!\n"
			 << "GNU, MICROSOFT VC7, BORLAND SUPPORTED\n"
			 << "--------------------------------------\n"
			 << "1) Set which makefiles to generate\n"
			 << "2) Set makefile compiler settings\n"
			 << "3) Set files for compilation\n"
			 << "4) Set output file name\n"
			 << "5) Generate makefiles\n"
			 << "6) Quit\n\n";

		cout << "Enter choice: ";
		cin >> choice;

		switch (choice)
		{
		case SETMAKEFILESTOGENERATE:
			SetMakefilesToGenerate();
			break;
		case SETCOMPILERSETTINGS:
			SetMakefileCompilerSettings();
			break;
		case ADDFILES:
			SetFilesToCompile();
			break;
		case SETOUTPUTFILENAME:
			SetOutputFileName();
			break;
		case GENMAKEFILES:
			GenerateMakefiles();
			break;
		}
	}


	return 0;
}